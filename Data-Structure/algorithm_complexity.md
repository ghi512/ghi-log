## Algorithm Complexity
### 알고리즘의 효율성
알고리즘의 효율성은 자원을 얼마나 효율적으로 사용하는지로 판단한다.<br>
이때 자원은 시간, 저장 공간, 네트워크 대역 등이며, 대부분은 시간에 관한 효율성에 대해 말한다.<br>
즉, 알고리즘의 성능(복잡도)는 대부분 수행 시간과 관련이 있고, 수행 시간은 입력의 크기에 대해 시간이 얼마나 걸리는지로 표현한다.<br><br>

### 알고리즘 수행 시간
다음은 입력의 크기가 n일때 수행 시간을 알 수 있는 알고리즘 예시들이다.
#### 예시 1
```python
def sample1(A, n):
    k = n // 2
    return A[k]
```
입력 배열의 크기 n에 상관없이 n // 2를 계산하고 해당 인덱스의 요소를 반환하기 때문에 알고리즘의 수행 시간은 <b>상수 시간(일정한 시간)</b>이다.<br>
#### 예시 2
```python
def sample2(A, n):
    sum = 0
    for i in range(n):
        sum += A[i]
    return sum
```
n 개의 원소를 가진 배열에 대해 for 루프를 통해 배열의 모든 요소를 한 번씩 확인하므로 알고리즘의 수행 시간은 입력 배열의 크기 <b>n에 비례</b>한다.
#### 예시 3
```python
def sample3(A, n):
    sum = 0
    for i in range(n):
        for j in range(n):
            sum += A[i] * A[j]
    return sum
```
이중 for 루프를 통해 배열의 모든 원소 쌍을 한 번씩 확인하고 해당 원소들의 곱을 합산하기 때문에 알고리즘의 수행 시간은 <b>n^2에 비례</b>한다.
#### 예시 4
```python
import random

def sample4(A, n):
    sum = 0
    for i in range(n):
        for j in range(n):
            max_val = max(random.sample(A, n//2)) # ①
            sum += max_val
    return sum
```
위 코드는 for 루프를 n^2번 반복하고, ①에서 배열에서 n/2개의 요소를 임의로 선택해 최댓값을 구한다. 즉, for 루프의 반복 횟수와 ①의 수행 시간이 시간을 좌우하므로 알고리즘의 수행 시간은 <b>n^3에 비례</b>한다.
#### 예시 5
```python
def sample5(A, n):
    sum = 0
    for i in range(n-1): # i는 0부터 n-2까지
        for j in range(i + 1, n-2): # j는 i+1 부터 n-1 까지
            sum += A[i] * A[j]
    return sum
```
위 코드는 반복 횟수가 매변 변하며, 표로 나타내면 아래와 같다. 
|i|내부 반복 횟수 (j)|
|------|---|
|0|n-1|
|1|n-2|
|..|..|
|n-3|2|
|n-2|1|

결국 for문의 총 반복 횟수는 (n-1)+(n-2)+...+2+1 = (n)*(n-1)/2 이 되고, 알고리즘의 수행 시간은 <b>n^2에 비례</b>한다.

#### 예시 6
자기호출이 일어나는 경우는 알고리즘 자체에서의 단순 산술로 분석할 수 없다.
```python
def factorial(n):
    if n == 1:
        return 1
    return n * factorial(n - 1)
```
위 코드는 재귀적으로 factorial 함수를 호출하여 팩토리얼을 계산하며, 이 경우 시간은 factorial()이 총 몇 번 호출되는지(얼마나 깊이 반복되는지)에 좌우된다. <br>

예를 들어, n=5인 경우 아래와 같다.
```
factorial(5)
   └── factorial(4)
       └── factorial(3)
           └── factorial(2)
               └── factorial(1)
```
factorial(1)은 ```if n == 1```의 조건에 걸려 factorial(0)을 호출하지 못하고 끝난다.<br>
즉, 입력값 n이 1이 될 때까지 계속해서 자기호출을 하며, 호출의 깊이는 n에 비례하게 된다. 따라서 알고리즘의 수행 시간은 <b>n에 비례</b>한다.

▹ 이처럼 알고리즘의 시간 복잡도를 분석할 때는 <b>수행 시간을 지배하는 부분이 어디인지 파악 하는 것</b>이 우선이다. 위의 예에서 for 루프의 반복 횟수, 특정 라인의 수행 횟수, 함수의 호출 횟수 등이 이에 해당한다. 정렬에서는 주로 두 수를 비교하는 횟수가 기준이 된다.<br><br>

### 알고리즘 복잡도
알고리즘의 복잡도는 <b>점근적 복잡도(Asymplotic Complexity)</b>로 나타낸다. 점근적 복잡도는 입력의 크기가 충분히 클 때의 복잡도를 의미하며, 이 분석에서는 최고차항의 차수만 중요하고 나머지는 모두 무시한다. 그래서 각 차수의 대표는 <b>계수가 없는 최고차항</b>이 된다. 즉, n, nLogn, n^2, 2^n 등이다.

<img width="395" alt="함수의 증가율" src="https://github.com/ghi512/ghi-log/assets/77954741/dd8c6d8a-287f-4b2e-a595-515124e246af"><br>

점근적 표기법에는 주로 세 가지가 사용된다.
```
✓ O(빅오)-표기: 점근적 상한
✓ Ω(오메가)-표기: 점근적 하한
✓ θ(세타)-표기: 점근적 동일
```
<img width="395" alt="점근적 표현" src="https://github.com/ghi512/ghi-log/assets/77954741/0ed65e41-4129-40f7-bcb1-140190772665"><br>

- <b>O(n^2)</b>
    - 최고차항의 차수가 n^2을 <b>넘지 않는</b> 모든 함수의 집합이다.<br>
    - 예) n^2, 3n^2 + 2n, 7n^2 - 100n, 3n^2 - 7nlogn, nlogn + 5n, 3n
- <b>Ω(n^2)</b>
    - 최고차항의 차수가 n^2을 <b>작지 않는</b> 모든 함수의 집합이다. <br>
    - 예) 5n^2-7n-8, 7n^3-100n, 2^n-5n, 10n^100
- <b>θ(n^2)</b>
    - 최고차항의 차수가 <b>정확히</b> n^2인 모든 함수의 집합이다. 
    - 즉, θ(n^2)은 항상 n^2에 비례하는 시간이 든다는 뜻이다. 
    - θ(n^2)은 O(n^2)와 Ω(n^2)의 교집합이다.
    - 예) n^2, 3n^2 + 2n, 7n^2 - 100nlogn