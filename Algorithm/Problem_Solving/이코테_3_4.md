## 1이 될 때까지
### 문제
- 시간 제한 : 1초
- 메모리 제한 : 128MB

<br>
어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 단, 두 번째 연산은 N이 K로 나누어떨어질 때만 선택할 수 있다.
<br><br>

1. N에서 1을 뺀다.
2. N을 K로 나눈다.

<br><br>
N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번 과정을 수행해야 하는 최소 횟수를 구하는 프로그램 작성하시오.
<br><br>

**입력 조건** <br>

- 첫째 줄에 N(2<=N<=100,000)과 K(2<=K<100,000)가 공백으로 구분되며 각각 자연수로 주어진다. 이때 입력으로 주어지는 N은 항상 K보다 크거나 같다.

**출력 조건** <br>
- 첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최소값을 출력한다.
<br>

---
### 내 풀이
🕰️ 문제 풀이 시간: 9m
```python
n,k = map(int, input().split())
cnt = 0

while n > 1:
    if n%k==0:
        n //= k
    else:
        n -= 1
    cnt += 1

print(cnt)
```
<br>

💡 **아이디어**
1) **첫번째 아이디어**
- 반복문 사용을 최대한 피하고 싶어 규칙을 찾고자 했다.
- n이 k의 배수일 때까지만 1을 사용하고, 나머지는 k를 사용하면 된다고 생각했다.
    ```python
    answer = n%k + n//k
    ```
- n//k이 k로 몇 번 나눴는지에 대한 값이 아닌, 또다시 연산 수행해야 하는 대상임을 깨달았다.
<br>
➡️  아이디어 폐기

2) **두번째 아이디어**
- 반복문 사용 (n이 1이 될 때까지)
- n이 k의 배수이면 k로 나누기, 아니면 1로 빼기
<br>
➡️ 이 아이디어가 모든 테케에 맞는 경우인지에 대해 불확실했는데,, 인터넷에서 다른 사람들의 답을 보니 모두 나랑 같은 코드를 써놨더라ㅎ 아무래도 제일 단순하게 떠올리는 코드인 것 같다. 근데 시간 측면에서 큰 입력이 들어오면 비효율적이므로 모범 답안처럼 생각할 수 있도록 해야겠다.
<br>

---
### 이코테 모범 답안
기본 아이디어는 **최대한 많이 나누기**이다. 2이상의 수로 나누는 것이 1로 빼는 것보다 숫자를 훨씬 많이 줄일 수 있기 때문이다. <br>
다만 문제에서는 N의 범위가 10만 이하이므로, 일일히 1씩 빼도 문제를 해결할 수 있지만 N이 100억 이상의 큰 수가 되는 경우도 생각해야 한다. 큰 수에도 빠르게 동작하려면, N이 K의 배수가 되도록 효율적으로 한 번에 빼는 방식을 사용해야 한다.
```python
# N, K공백을 기준으로 구분하여 입력 받기
n, k = map(int, input().split())

result = 0

while True:
    # N이 K로 나누어 떨어지는 수가 될 때까지만 1씩 빼기
    target = (n // k) * k
    result += (n - target)
    n = target
    # N이 K보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출
    if n < k:
        break
    # K로 나누기
    result += 1
    n //= k

# 마지막으로 남은 수에 대하여 1씩 빼기
result += (n - 1)
print(result)
```

**이코테 코드 분석**
- 단순하게 푸는 방법은 1을 빼는 만큼의 무식한 반복이 계속되기 때문에 뭉텅이로 1을 빼준다.
- ```target``` 
    - 현재 N보다 작은 수 중, 가장 큰 K의 배수. 즉 N이 되어야 하는 타켓값.
- ``` result += (n - target)```
    - 현재 N의 값에서 target이 되려면 1을 빼는 방식을 써야 한다.
    - 이 코드가 1을 반복문을 통해 빼는 것이 아닌 뭉텅이로 빼도록 만든 부분이다.
- ```n = target```
    - 1을 뺀 횟수를 result에 더했으므로 이제 n을 target값으로 만든다.
- 이후 N이 K로 나눌 수 있으면(N>=K) 나누고 반복한다.
- ```result += (n - 1) ```
    - N이 K로 나눌 수 없어지면, N이 1이 될 때까지 다시 1씩 빼기를 반복해야 한다.
    - 즉, 1 빼기가 n-1번 반복되어야 하므로 결과값에 n-1을 더한다.

**후기**
- 모범 답안을 처음에 보고 이해가 잘 안됐다.. 예시 값을 정하고 생각하며 직접 손으로 반복문을 돌려보니 그제서야 이해가 됐다! 생각을 하자~
- 내가 생각한 아이디어 1에서 막힌 부분(k로 나눈 몫에 대한 해결법)을 끝까지 해결했으면 모범 답안과 비슷한 답안이 나왔을텐데 아쉽다.. 막힌 부분에서 포기하지 말고 잘 생각해보자! 큰 입력이 들어왔을 때 시간초과가 되지 않을 코드가 필요하다.